模板和标准模板库(STL)
一、模板起源
数据类型
int var = 30;
int* p = &var;
++var;
++p;
内存空间、存储形式、计算规则。
动态(运行时间)类型语言：JavaScript
静态(编译时间)类型语言：C/C++
优势：高性能，安全。
劣势：编译时间长，灵活性差。
参见：typed.cpp
通过宏函数摆脱源自静态类型的约束。
参见：untyped.cpp
既有函数的类型安全性，同时又具备宏的类型无关性。
参见：macro.cpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

二、函数模板
1.定义
template<typename 类型形参1,typename 类型形参2, ...>
返回类型 函数模板名 (调用形参表) 
{
  函数体
}
所谓类型形参，其实就是参数化类型，可以在函数模板的返回类型、调用形参以及函数体中被引用。

template<typename A, typename b, typename _C>
A function (b arg) 
{ 
	... _C var; ... 
}

2.使用
函数模板名<类型实参1, 类型实参2, ...> (调用实参表);
int i = function<int, double, string> (3.14);
double d = function<double, string, int> ("圆周率");

编译器将类型实参按照先后顺序与函数模板中的类型形参一一结合，将模板化的函数编译成具体函数，以供调用。因此，函数模板所表示的不是一个函数，而是一族具有相同逻辑特征的函数。
参见：ftmpl.cpp
实例化：在编译阶段由编译器将函数模板结合类型实参变成具体函数的过程，谓之函数模板的实例化。每个这样的具体函数就是该函数模板的一个实例。

3.类型参数
1)类型形参：必须是有效标识符，必须被typename关键字修饰。
2)类型实参：所提供的操作规则必须满足模板的需要，否则将导致编译失败。
参见：targ.cpp

4.二次编译
1)普通函数
void foo (void); // 声明，仅供编译器进行类型检查
...
foo (); // 调用，完成链接
...
void foo (void) { ... } // 定义，仅编译一次

2)模板函数
template<typename T>
void foo (void); // 声明
...
foo<int> (); // 调用，第二次编译(延迟编译)
...
template<typename T>
void foo (void) { ... } // 定义，第一次编译

当编译器"看到"函数模板定义时，由于其类型参数尚不明确，只做与类型无关的一般性语法检查，如无误则生成关于该函数模板的内部表示；当编译器"看到"该函数模板被调用时，再用所提供的类型实参结合该模板内部表示中的类型形参，做与类型相关的语法检查，如无误则生成具体的二进制指令代码。这种针对模板化函数的特殊编译过程，被称为延迟编译或二次编译。
参见：typename.cpp


5.隐式推断
如果函数模板调用参数(圆括号里的参数)的类型与该模板的模板参数(尖括号里的参数)相关，那么在调用该函数模板时，即使不显式指定类型实参，编译器也有能力根据调用参数的类型，推断出模板参数的实际类型，这就叫做函数模板类型参数的隐式推断。请注意，如果编译器隐式推断的类型与程序设计者所期望的类型不一致，那么就只能使用显式实例化以确保结果正确。
参见：ftmpl.cpp、deduc.cpp

6.重载
1)和普通函数一样，在同一个作用域中名称相同，参数表不同的函数模板之间，以及函数模板和普通函数之间，可以构成重载关系。
2)除了根据参数类型的一致性进行重载解析的条件之外，对于函数模板还要考虑类型约束性的强弱，类型约束性越强者越被优先选择：普通函数>半模板函数>全模板函数。
参见：overload.cpp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

三、类模板
如果一个类的成员变量、成员函数、成员类型，甚至基类中出现参数化的类型，那么这个类就是一个类模板。
1.定义
template<typename 类型形参1,
    typename 类型形参2, ...>
class 类模板名 [: 继承方式 基类] {
    成员变量
    成员函数
    成员类型
};
其中基类、成员变量、成员函数和成员类型中都可以引用类型形参。
template<typename M, typename R, typename A,typename V, typename T, typename B>
class MyClass : public B 
{
  M m_var;
  R fun (A arg) 
  { 
	... V var; ... 
  }
  typedef T* pointer;
};

2.使用
类模板名<类型实参 1, 类型实参2, ...> 对象 (构造实参表);
类模板名<类型实参 1, 类型实参2, ...>& 引用  = 对象;
类模板名<类型实参 1, 类型实参2, ...>* 指针 = &对象;
|<----------------------------------->|
                             类
类模板的类型参数不能隐式推断，必须显示指明！类模板不能作为类型看待，只用通过类型实参表被实例化为类才是一个具体类型，可以用于对象的创建，以及引用或者指针的声明。
两步实例化：
             编译期           运行期
类模板 -实例化-> 类 -实例化-> 对象
             编译器           处理器
参见：ctmpl.cpp

3.类型参数
1)类模板中的成员函数都是模板函数，只有那些实际被调用的成员函数才会被二次编译，因此某些类型实参虽然没有提供类模板所需要的全部功能，但照样可以实例化该类模板，只要不直接或间接调用那些依赖于未提供功能的成员函数即可。
2)作为模板的设计者，应该尽可能地减少对类型参数的功能性要求，以降低模板使用者的代码复杂度。
==/!=/</<=/>/>=
==/<
参见：ctmpl.cpp

4.静态成员变量
语法：static，类外单独定义初始化
逻辑：隶属于类而非对象，为该类的所有对象共享
物理：存储静态区，进程级生命周期
类模板中的静态成员变量，既不是一个模板一份实例，也不是一个对象一份实例，而是在该类模板的每个实例化类中都有一份实例，且为该实例化类的每个实例化对象所共享。
参见：static.cpp

5.递归实例化
int a = 5;
int b = 10;
a = b;
void foo (int x) 
{ 
	++x; 
}
foo (a);
a ? 10
---------------------------
int a[3] = {10, 20, 30};
int b[3] = {40, 50, 60};
a = b; // 错误！
void foo (int x[3]) 
{ 
	++x[0]; 
}; // int* x
foo (a);
a[0] ? 11

用一个类模板的实例化类型实例化该类模板自身，位置递归实例化。通常用这种方法构造那些在空间上具有递归特性的数据结构，比如：多维数组、二叉树、广义表等等。
参见：array.cpp

复合嵌套
template<typename T> class Array;
template<typename T> class List;
template<typename T> class Tree;
Array<List<int> > a; // 链表数组
List<Array<int> > b; // 数组链表
Tree<List<Array<int> > > c; // 数组链表二叉树
...

6.特(例)化
如果一个类模板的通用版本不能很好地支持某些特殊的类型实参，或者结果错误，或者性能不佳，那么就可以针对这些特殊类型给出关于该类模板的特殊实现，以作为对通用版本的补充。

1)完全特化：特化所针对的是类模板的全部类型参数。

A.全类模板特化：将类模板的类型参数取具体类型，按照一个具体类给出完整的定义。
template<> // 不能省略
class 类模板名<类型实参表> 
{ ... };

B.成员特化：只针对类模板中各个别成员函数，给出其针对特定类型的特殊实现。
template<> // 可以省略
返回类型 类模板名<类型实参表>::成员函数名 (调用形参表) 
{
     ...
}
参见：spec.cpp

2)局部特化：特化所针对的是类模板的部分类型参数，或者类型参数的某种属性及关系。当通用版本、局部特化和完全特化同时存在时，编译器总是优先选择类型约束性最强的版本：
完全特化>局部特化>通用版本
参见：part.cpp

7.智能指针
int a = 10;
int* p = &a;
int* q = p;
参见：auto.cpp


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
四、其它特性
1.模板参数的缺省值
1)类模板的模板参数可以带有缺省值，实例化该类模板时，如果提供了模板实参，则用所提供的模板实参实例化相应的模板形参，如果没有提供模板实参，则对应的模板形参取缺省值。
2)如果为类模板的某个模板参数指定了缺省值，那么该模板参数后面的所有模板参数必须都带有缺省值。
3)在C++98/03标准中函数模板不可以带有缺省模板参数，但C++11标准放开此限制，需要为编译器指定语言标准选项：
GCC < 4.8 : -std=c++0x
GCC >= 4.8 : -std=c++11
4)与函数不同，模板参数的缺省值可以取自该参数之前的参数。
5)如果函数模板的某个模板参数可以通过隐式推断确定其类型，即使它前面的参数带有缺省值，该参数也可以不带缺省值。
6)对于函数模板，如果隐式推断的类型参数与该参数的缺省值不一致，以隐式推断的类型为准，忽略其缺省值。
参见：defarg.cpp

2.模板的非类型参数
1)模板的参数除了用typename声明的类型参数以外，还可以是带有具体类型的数值参数，谓之模板的非类型参数。
2)能够作为传递给模板非类型参数的实参必须是常量、常量表达式、带有常属性(const/C限定)的变量，但是不能同时具有挥发性(volatile/V限定)。
3)GNU编译器的限制
模板的非类型参数仅限于整型：
[signed/unsigned]char/short/int/long/long long
不能使用浮点型：
float/double/long double/long long double
类类型对象不能作为模板的非类型参数。
如果用字符串作为模板的非类型参数，其形参必须使用字符指针，实参必须是具有外部链接特性(非static)的全局字符数组。
参见：array2.cpp

3.typename关键字
1)声明模板的类型参数
template<typename 类型参数> ... // 新风格
template<class 类型参数> ... // 旧风格
2)解决嵌套依赖
在第一次编译模板代码时，模板参数的具体类型尚不明确，编译器会把依赖于模板参数的嵌套类型理解为某个类的静态成员变量。因此当它看到使用这样的标识符声明其它变量时，会报告错误，这就叫嵌套依赖。typename关键字旨在告诉编译器，所引用的标识符是一个类型名，可以声明变量，具体类型等到第二次编译再做检查。
参见：typename.cpp
       struct \
         class - 声明类
                   \ 声明模板的
                   / 类型参数
typename - 解决嵌套依赖

4.template关键字
1)声明模板
template<...> 返回类型 函数模板名 (调用形参表) { ... }
template<...> class 类模板名 { ... };
2)解决嵌套模板
引用依赖于模板的类型参数的模板的内部模板。
在模板代码中，通过依赖于模板参数的对象、引用或指针，访问其带有模板特性的成员，编译器常常因为无法正确理解模板参数列表的左右尖括号，而报告错误。在模板名前面加上template关键字，意在告诉编译器其后的名称是一个模板，编译器就可以正确理解"<>"了。
参见：template.cpp

5.类模板继承
在子类模板中直接访问那些依赖于模板参数的基类模板的成员，编译器在第一次编译时，通常会因为基类类型不明确而只在子类和全局作用域中搜索所引用的符号，引发编译错误。通过作用域限定符，或显式使用this指针，可以迫使编译器到基类作用域中搜索所引用的符号，保证编译通过。
参见：inherit.cpp

6.内部模板的外部定义
一个类模板的内部可以再定义类模板和函数模板，内部模板的实现可以在外部模板的外部，但其类型参数必须声明于独立的template子句，且要按照其作用域从外到内的顺序，从前到后依次排列。
参考：outer.cpp

7.模板型模板参数
如果一个模板的模板参数所结合的类型实参本身又是一个模板，那么该参数不能用typename关键字声明，而要写成如下形式：template<模板型类型实参的参数表> class 参数名。
参见：stack.cpp

8.零初始化
基本类型不存在缺省构造函数，未被显式初始化的局部变量都已一个不确定的值。包含(自定义或系统提供的)缺省构造函数的类，在未被显式初始化的情况下，都会有一个确定的初始状态。二者之间存在语义上的不一致性。为了获得统一的初始化效果，C++可引入了所谓零初始化语法：T var = T ()，不论T是基本类型还是类类型，被初始化的变量都有确定的初值。基本类型被初始化相应类型的"0"，类类型调用相应的缺省构造函数。
参见：init.cpp

9.模板与多态
1)在一个类模板中可以声明虚函数，只要它的子类模板在实例化过程中所接受的类型实参不违背虚函数有效覆盖的条件，那么基于虚函数的多态性同样适用于类模板。
2)无论是类还是类模板，其虚成员函数不能同时又是模板函数。基于虚函数的多态机制，需要一个名为虚函数表的函数指针数组。该数组在类被编译或类模板被实例化的过程中产生，而此时那些模板形式的成员函数尚未被二次编译，其入口地址和重载版本的个数，要等到编译器处理完对该函数的所有调用语句以后才能确定。成员函数模板的延迟编译阻碍了虚函数表的静态构建。
参见：poly.cpp
3)广义多态：通过一种形式实现多种功能。
A.动态多态：基于虚函数和动态绑定。
B.静态多态：基于类型参数和模板。
参见：dpoly.cpp、sploy.cpp

10.编译模型
1)单一模型：将声明、实现和使用放在同一个源文件中。
优点：源代码集成度高。
缺点：难于维护，难于协作开发。
2)分离模型：将声明、实现和使用分别放在不同的源文件及头文件中。
优点：易于维护，易于协作开发。
缺点：无法对模板做二次编译，导致链接失败。
参见：div/
3)包含模型：在声明模板的头文件尾部包含实现模板的源文件。
优点：成功地完成对模板的二次编译，顺利通过链接。
缺点：模板实现代码必须公开，延迟编译时间。
参见：inc/
4)实例模型：在模板的实现文件中做显式实例化，迫使编译器提前对该模板进行二次编译，保证链接成功。
优点：链接成功、模板实现代码不必公开、不影响编译时间。
缺点：实例化类型有限，不够通用。
参见：ins/
5)导出模型：通过export关键字将模板声明为导出，强制编译器将模板的内部表示延迟到二次编译阶段。
优点：模板实现代码不必公开、不影响编译时间、类型不受限
缺点：绝大多数的主流编译器都不支持export关键字。
C++2011/14/17标准中已经将导出模型废除了！

11.预编译头

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
五、容器、迭代器和泛型算法
容器：模板化的数据结构。
泛型算法：模板化的算法。
迭代器：为不同类型的容器提供相同形式的数据访问接口。
双向线性链表容器、正向顺序可写迭代器、线性查找算法。
参见：list.cpp

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

六、标准模板库(Standard Template Library, STL)
1.基本内容
1)容器
A.线性容器
a)向量(vector)
b)双端队列(deque)
c)列表(list)
B.适配器容器
a)堆栈(stack)
b)队列(queue)
c)优先队列(priority_queue)
C.关联容器
a)映射(map)
b)多重映射(multimap)
c)集合(set)
d)多重集合(multiset)
2)迭代器
A.根据迭代特性：单向迭代器和双向迭代器
B.根据迭代方向：正向迭代器和反向迭代器
C.根据迭代运算：顺序迭代器和随机迭代器
D.根据目标访问：可写迭代器和只读迭代器
每一种容器会以嵌套类的形式提供至少四种迭代器类型：
iterator - 正向可写迭代器
const_iterator - 正向只读迭代器
reverse_iterator - 反向可写迭代器
const_reverse_iterator - 反向只读迭代器
只有向量和双端队列，这种内存连续的容器才会提供随机迭代器，其它容器由于内存不连续，只提供顺序迭代器。
3)泛型算法
大多数都会通过迭代器操作不同的容器类型，提供常用的非数值算法，如查找、排序、拆分、合并、复制、交换、移动等等

2.向量(vector)
1)基本特性
A.连续内存和下标访问
B.动态内存管理

2)实例化
#include <vector>
using namespace std;
A.vector<元素类型> 向量对象; // 空向量
vector<int> vi;
cout << vi.size () << endl; // 0
cout << sizeof (vi) << endl; // 12
容器大小：元素个数，size()
容器对象大小：容器本身的字节数，sizeof()
B.vector<元素类型> 向量对象 (初始大小); // 非空向量
vector<int> vi (3);
基本类型：初始化为"零"
类类型：用缺省构造函数初始化
C.vector<元素类型> 向量对象 (初始大小, 初始值);
vector<int> vi (3, 5); // 5 5 5
vector<Student> vs (3, Student ("张飞", 22));
D.vector<元素类型> 向量对象 (起始迭代器, 终止迭代器);
int ai[5] = {10, 20, 30, 40, 50};
vector<int> v1 (ai, ai + 5); // 10 20 30 40 50
vector<int> v2 (&ai[0], &ai[5]); // 10 20 30 40 50
vector<int> v3 (ai+1, ai + 4); // 20 30 40
在STL中但凡用两个迭代器表示一个元素范围时，其中的终止迭代器一定是该范围中最后一个元素的下一个位置。
参见：vec1.cpp

3)迭代器
A.随机迭代器：在顺序迭代器的基础上又增加了如下功能：
可以和整数做加减法运算；
同类型的迭代器之间可以做大小比较运算和相减运算。
B.八个特征迭代器
iterator begin (void)
iterator end (void)
reverse_iterator rbegin (void)
reverse_iterator rend (void)
const_iterator begin (void) const
const_iterator end (void) const
const_reverse_iterator rbegin (void) const
const_reverse_iterator rend (void) const
begin - 起始
end - 终止
不带const - 可写
带const - 只读
不带r - 正向
带r - 反向
对于正向迭代器而言，起始位置在首元素，终止位置在尾元素之后；对于反向迭代器而言，起始位置在尾元素，终止位置在首元素之前。
任何可能导致容器结构发生变化的操作，比如数据元素的增删，都可能引发其内存布局的调整，因此操作之前所获得的迭代器就会因为这种调整而失效，安全起见最好重新定位这个迭代器以后再继续使用。
参见：vec2.cpp

4)成员函数
front
back/push_back/pop_back
insert/erase // insert (vi.begin (), 10)
                      // erase (vi.begin ())
                      // 效率较低
size/capacity/resize/reserve
clear/empty

5)查找和排序
#include <algorithm>
A.查找
template<typename IT, typename T>
IT find (IT begin, IT end, T const& key);
在[begin,end)区间内查找第一个和key匹配的元素，成功返回指向该匹配元素的迭代器，否则返回end。
B.排序
IT sort (IT begin, IT end);
对[begin,end)区间内的元素做快速排序。
IT sort (IT begin, IT end, CMP cmp);
参见：vec3.cpp

6)存放类类型元素的容器
如果容器中的元素类型是自己定义的类，那么该类往往需要根据不同情况满足如下条件：
缺省构造函数；
具有深拷贝语义的拷贝构造函数和拷贝赋值运算符函数；
重载"=="或"<"运算符函数。
参见：vec4.cpp

3.双端队列(deque)
1)内存结构和操作接口几乎和向量完全相同，唯一的区别就是双端队列是两端开发的容器，因此可以在容器首尾两端，以相同的时间复杂度进行元素的压入和弹出。因此，相比向量增加了从首部和尾部压/弹数据元素的接口：push_front/pop_front
2)为了降低实现的难度，相比向量去除了两个接口：
capacity/reserve
3)整体而言双端队列比向量的时空复杂要高一些，因此性能略差。

4.列表(list)
1)唯一化
void unique (void);
仅对容器中连续的重复出现的元素做唯一化，而不是对整个容器中的元素做唯一化。
10 10 20 20 10 20 30 20 20 10 10
                           | unique()
                           V
10       20      10 20 30 20      10

2)排序
void sort (void); // 用元素类型的"<"运算符比较大小
void sort (CMP cmp); // 用比较器比较大小
<algorithm>头文件中的全局函数sort()只能应用于带有随机迭代器的连续内存容器，比如vector、deque。列表的排序必须使用其成员函数sort()。

3)拆分：调用列表.splice (目标迭代器, 参数列表, ...);
从参数列表中剪切出全部或者部分元素，插入到调用列表中目标迭代器之前。
void splice (IT pos, list& lst); // 剪切全部
void splice (IT pos, list& lst, IT del); // 剪切一个
void splice (IT pos, list& lst, IT begin, IT end); //剪切区间

4)合并：将两个有序列表合并为一个，仍然保持有序。
void merge (list& lst); // <
void merge (list& lst, CMP cmp); // 比较器
参见：list.cpp

5.堆栈、队列、优先队列
1)堆栈(stack)
push -> push_back
pop -> pop_back
top -> back
size -> size
empty -> empty
底层容器：vector/deque(缺省)/list

2)队列(queue)
push -> push_back
pop -> pop_front
back -> back
front -> front
size -> size
empty -> empty
底层容器：deque(缺省)/list

3)优先队列(priority_queue)
优者先出，缺省优先级规则就是大者为优。如果希望自定义优先级规则，可以通过比较器作为类模板的参数提供给优先队列。这里的比较器只能使用仿函数类型，而不是使用函数指针。
底层容器：vector/deque(缺省)
首             尾
40 35 30 20
参见：sqp.cpp

6.映射、多重映射、集合、多重集合
1)映射(map)
A.存放键值对的容器。
B.键必须唯一，表示一一对应。
C.采用红黑树(平衡有序二叉树)作为内部数据结构，以键为排序基准，在O(logN)对数级时间内完成根据键查找值的操作。
10 20 30 40 50
10
    \
     20
         \
          30
              \
               40
                   \
                    50
在任何节点上看，其左右子树中的节点个数最多相差一个，叫平衡树，符合该特征的有序二叉树，谓之平衡有序二叉树，又名红黑树。
          30
     20      40
10                50
D.映射构建速度较慢，搜索速度快，一般用作相对稳定的数据集合。
E.映射结构中，每个元素包括键和值两个不同类型数据，因此采用pair容器保存元素的数据。
template<typename FIRST, typename SECOND>
class pair {
public:
    pair (FIRST const& f, SECOND const& s) :
        first (f), second (s) {}
    FIRST first;            // 键
    SECOND second; // 值
};
映射的迭代器相当于是指向pair对象的指针。
F:支持下标运算符"[]"，但是其右操作数不是整型索引号，而是键对象，其表达式的值是与该键对应的值的引用。
G:map<键的类型, 值的类型>
map<string, int> m;
m["张飞"] = 90;
++m["张飞"];
cout << m["张飞"] << endl; // 91
无论迭代是只读还是可写，其目标元素的键，永远都是只读的。
参见：map.cpp

2)多重映射(multimap)
允许键重复的映射。逻辑上表示一多对应。不支持下标运算符。
pair<IT, IT> equal_range (KEY const& key);
IT lower_bound (KEY const& key);
IT upper_bound (KEY const& key);
参见：mmap.cpp

3)集合(set)
没有值的映射。元素必须唯一。迭代的结果升序序列。用于排重。动态有序。
4)多重集合(multiset)
允许元素重复的集合。
没有值的多重映射。
参见：set.cpp


